<?xml version="1.0" encoding="utf-8"?>
<rss version="2.0"><channel><title>Charles Chen's blog - Charles Chen</title><link>http://seekiu.com/</link><description></description><lastBuildDate>Tue, 07 Mar 2017 15:27:00 +0800</lastBuildDate><item><title>蒙特卡洛方法模拟赌博策略</title><link>http://seekiu.com/2017/monte-carlo-betting.html</link><description>&lt;p&gt;最近玩了一些关于用蒙特卡洛方法模拟赌博策略的测试，一些结果托管在 Jupyter 
nbviewer 上了，有兴趣的可以看一下：&lt;a href="https://nbviewer.jupyter.org/github/seekiu/iPythonNotebooks/tree/master/Monte%20Carlo%20simulation%20of%20betting%20strategies/"&gt;链接&lt;/a&gt;&lt;/p&gt;</description><dc:creator xmlns:dc="http://purl.org/dc/elements/1.1/">Charles Chen</dc:creator><pubDate>Tue, 07 Mar 2017 15:27:00 +0800</pubDate><guid isPermaLink="false">tag:seekiu.com,2017-03-07:/2017/monte-carlo-betting.html</guid><category>个人</category></item><item><title>关闭 Win10 的自动更新（和重启！）</title><link>http://seekiu.com/2016/close-auto-update-win10.html</link><description>&lt;p&gt;Win10在默认情况下是打开自动更新的，这本身对多数人来说应该是好事，但有一个非常非常恶心人的设定是同时也会自动重启。重启前甚至还无视其它程序的状态，不管有没有正在修改的文件没有保存，说重启就重启，这是非常糟糕的设计。&lt;/p&gt;
&lt;p&gt;所幸的是在专业版的 Win10 中还可以把这个选项给关闭（据说家庭版是没法修改的，未确认），但不是通过系统带的那个「设置」，而是需要用组策略编辑器来修改，步骤如下：&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;按 Win+R 打开运行窗口，输入 &lt;code&gt;gpedit.msc&lt;/code&gt;，回车，打开组策略编辑器。&lt;/li&gt;
&lt;li&gt;在左侧栏中依次找到「计算机配置」-「管理模板」-「Windows组件」-「Windows更新」，点击后在右侧双击打开「配置自动更新」，改为「已启用」，左下改为「2-通知下载并通知安装」。&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;这样设置后，每次有更新的时候会提示，点击了下载之后才会安装，虽然略微更麻烦一点点，但把那种不知道什么时候会重启的不确定性完全消除了。&lt;/p&gt;</description><dc:creator xmlns:dc="http://purl.org/dc/elements/1.1/">Charles Chen</dc:creator><pubDate>Fri, 11 Nov 2016 13:24:00 +0800</pubDate><guid isPermaLink="false">tag:seekiu.com,2016-11-11:/2016/close-auto-update-win10.html</guid><category>PC-tips</category></item><item><title>修正 Inkscape 编辑 matplotlib 导出的文件时内存泄漏的问题</title><link>http://seekiu.com/2016/fix-inkscape-memory-leak.html</link><description>&lt;p&gt;以前的文章中提到，在 matplotlib 中做标注相比 Origin 来说比较麻烦，但可以输出 SVG 格式，然后用 Inkscape 来做标注，不管是标注文字还是箭头一类，都比较简单。而且 SVG 由于它是一种很标准的通用格式，可以很容易转成 PDF、EMF 或者其它格式。然而最近发现了一个问题，较新版本的 matplotlib 导出的 SVG 在用 Inkscape 编辑时，存在内存泄漏的问题。任何一个几十 kB 的文件，打开后 Inkscape 也会占用几个 G 甚至更大的内存，操作也会变得非常卡顿，十分不正常。&lt;/p&gt;
&lt;p&gt;在&lt;a href="https://bugzilla.redhat.com/show_bug.cgi?id=1299222"&gt;这个帖子&lt;/a&gt;中较为详细地分析了问题的成因，主要原因是 miterlimit 默认被设置成了 100000。恰好由于 Inkscape 渲染 …&lt;/p&gt;</description><dc:creator xmlns:dc="http://purl.org/dc/elements/1.1/">Charles Chen</dc:creator><pubDate>Thu, 29 Sep 2016 14:50:00 +0800</pubDate><guid isPermaLink="false">tag:seekiu.com,2016-09-29:/2016/fix-inkscape-memory-leak.html</guid><category>matplotlib</category></item><item><title>用 matplotlib 画出规范的论文插图</title><link>http://seekiu.com/2016/mpl-for-publish.html</link><description>&lt;p&gt;我最近所写的论文中基本上放弃了 Origin，而转为用 matplotlib 画几乎所有的插图。相比专业的 Origin，MPL 基本可以替代所有的功能，甚至单论功能还略有胜出。从可定制性角度，两者也接近，但 MPL 没有 Origin 图形化操作的直观性，这方面有所欠缺。而且 MPL 默认的主题和格式都与论文所要求的质量相去甚远，不像 Origin 一样基本默认格式就能凑合用了。&lt;/p&gt;
&lt;p&gt;从我自己的研究领域来看，插图的规范性，主要有几个方面的问题需要设置：&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;尺寸，包括图形尺寸、线宽等&lt;/li&gt;
&lt;li&gt;标注，包括对图线的标注、legend等&lt;/li&gt;
&lt;li&gt;图层，叠加不同的坐标轴等&lt;/li&gt;
&lt;li&gt;文字样式、字号等&lt;/li&gt;
&lt;li&gt;输出格式&lt;/li&gt;
&lt;/ol&gt;
&lt;h1&gt;一个基本图形的示例&lt;/h1&gt;
&lt;p&gt;下面给出了一个示例的代码，通过自定义各种格式基本上可以说符合正式出版的要求：&lt;/p&gt;
&lt;table class="highlighttable"&gt;&lt;tr&gt;&lt;td class="linenos"&gt;&lt;div class="linenodiv"&gt;&lt;pre&gt; 1
 2
 3
 4
 5
 6
 7
 8
 9 …&lt;/pre&gt;&lt;/div&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;</description><dc:creator xmlns:dc="http://purl.org/dc/elements/1.1/">Charles Chen</dc:creator><pubDate>Fri, 05 Aug 2016 15:08:00 +0800</pubDate><guid isPermaLink="false">tag:seekiu.com,2016-08-05:/2016/mpl-for-publish.html</guid><category>matplotlib</category><category>DS相关</category></item><item><title>检查多维 ndarray 中是否有某元素</title><link>http://seekiu.com/2016/membership-in-ndarray.html</link><description>&lt;p&gt;最近又在写科学计算的代码了。今天偶然发现一个 Numpy 中的一个小问题，不注意的话还是很容易踩坑的。&lt;/p&gt;
&lt;p&gt;通常来说，检查一个类似列表的对象中是否有某个元素，最直接的办法是用 &lt;code&gt;in&lt;/code&gt;。这个方法对列表、字典、元组等都适用，对一维的 ndarray 对象也适用，例如：&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;a = [1, 2, 3]
print(4 in a)
b = np.array(a)
print(4 in b)
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;结果是&lt;code&gt;False False&lt;/code&gt;&lt;/p&gt;
&lt;p&gt;但是，如果这个 ndarray 是二维的数组，结果就非常奇怪了：&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;a = [[0,0], [0,1]]
print([0,2] in a …&lt;/pre&gt;&lt;/div&gt;</description><dc:creator xmlns:dc="http://purl.org/dc/elements/1.1/">Charles Chen</dc:creator><pubDate>Mon, 11 Jul 2016 18:39:00 +0800</pubDate><guid isPermaLink="false">tag:seekiu.com,2016-07-11:/2016/membership-in-ndarray.html</guid><category>Python</category></item><item><title>保存网页到本地的方法（2）</title><link>http://seekiu.com/2016/save-web-page-more.html</link><description>&lt;p&gt;前一篇&lt;a href="http://seekiu.com/2016/save-web-page-locally.html"&gt;文章&lt;/a&gt;中讲了我常用的保存网页到本地的办法，最近又有一些新的发现。&lt;/p&gt;
&lt;p&gt;首先是 pandoc 转 docx 到 markdown 对 pandoc 的版本是有要求的，目前版本是1.17.1，可以正确处理带中文的文件。但如果用的是更旧的版本（似乎是1.15以前），会提示无法解码 UTF-8，因此推荐先把 pandoc 版本更新。&lt;/p&gt;
&lt;p&gt;本文最主要想更新的是一个新的发现，我找到了一个叫 &lt;a href="http://www.typora.io/"&gt;Typora&lt;/a&gt; 的软件，它本身是一个支持所见即所得的 markdown 编辑器（从知乎上的讨论来说，实现这样的东西似乎难度还很大），但它居然还支持了粘贴网页直接转换成 markdown 的功能。也就是说，不再需要手动保存成 docx，只需要把网页直接粘到里面就已经是 markdown 了。&lt;/p&gt;
&lt;p&gt;还有一点很重要的特性，就是由于它本身所见即所得的特性，相当于每次打开 md 文件都会自动渲染成网页格式，所以甚至省掉了再重新转换成 html …&lt;/p&gt;</description><dc:creator xmlns:dc="http://purl.org/dc/elements/1.1/">Charles Chen</dc:creator><pubDate>Thu, 07 Jul 2016 08:30:00 +0800</pubDate><guid isPermaLink="false">tag:seekiu.com,2016-07-07:/2016/save-web-page-more.html</guid><category>Tips</category></item><item><title>保存网页到本地的两种办法</title><link>http://seekiu.com/2016/save-web-page-locally.html</link><description>&lt;p&gt;Edit: &lt;a href="http://seekiu.com/2016/save-web-page-more.html"&gt;后续更新&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;自从不太使用 Evernote 之后，如何干净地保存网页信息就成了一个大问题。所谓「干净」，就是只保存网页主体的信息，而不包括其它不相关的部分，也就相当于保存下 Firefox 所提供的阅读模式中显示的内容。&lt;/p&gt;
&lt;p&gt;本来，Evernote 提供的「悦读」是一个很好的方案，它首先提供了一个阅读模式，可以很好地对绝大多数网页实现抓取，然后它可以直接保存到 Evernote，可以说基本解决了我的需求。但由于各种原因，我现在基本不用 Evernote，使得这个需求还不太好自己解决了。&lt;/p&gt;
&lt;p&gt;最开始想的办法是自己写一个 Python 脚本，爬一下网页，然后抓取主体信息，最后保存，看起来似乎每一个环节都不复杂，但尝试写了一下发现还是很麻烦：不同网站网页结构不同，涉及到如何分别处理的问题；有些文章需要翻页；有些网站如知乎专栏为了防转载做了不少障碍，等等。最终发现这个脚本要达到预期的目的，远不是半个下午就能轻松解决的小项目，暂时就打消了这个念头。&lt;/p&gt;
&lt;p&gt;经过一些有意搜索和偶然的发现，现在有两种对我而言比较合适的方法。&lt;/p&gt;
&lt;p&gt;方法一是打印到 PDF。这个需要用到微软的 Edge 浏览器 …&lt;/p&gt;</description><dc:creator xmlns:dc="http://purl.org/dc/elements/1.1/">Charles Chen</dc:creator><pubDate>Mon, 27 Jun 2016 16:29:00 +0800</pubDate><guid isPermaLink="false">tag:seekiu.com,2016-06-27:/2016/save-web-page-locally.html</guid><category>Tips</category></item><item><title>Git 笔记</title><link>http://seekiu.com/2016/git-notes.html</link><description>&lt;blockquote&gt;
&lt;p&gt;声明：这个笔记是根据我自己的理解所写，可能有部分理解有误或不全，仅供参考。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;以前在装 Vundle 的时候安装了 Git，但只作为 Vundle 的后台使用，没有直接使用过 git。趁着这次搬博客的机会，大致学会了基础的使用，本文是对 git 基本操作尤其是与 github 结合的一个简单笔记，适合零基础的人入门，也作为我自己的一个参考手册。&lt;/p&gt;
&lt;hr&gt;
&lt;h1&gt;最简版&lt;/h1&gt;
&lt;ul&gt;
&lt;li&gt;&lt;code&gt;git init&lt;/code&gt;，新建一个 repo&lt;/li&gt;
&lt;li&gt;&lt;code&gt;git clone &amp;lt;some_url&amp;gt; [destination_dir]&lt;/code&gt;，从 Github 或其它网站下载 repo 的完整内容&lt;/li&gt;
&lt;li&gt;修改文件，然后 &lt;code&gt;git status&lt;/code&gt; 查看有哪些修改&lt;/li&gt;
&lt;li&gt;&lt;code&gt;git add .&lt;/code&gt; 添加所有的修改到 stage&lt;/li&gt;
&lt;li&gt;&lt;code&gt;git status&lt;/code&gt;，确认所有修改&lt;/li&gt;
&lt;li&gt;&lt;code&gt;git commit …&lt;/code&gt;&lt;/li&gt;&lt;/ul&gt;</description><dc:creator xmlns:dc="http://purl.org/dc/elements/1.1/">Charles Chen</dc:creator><pubDate>Mon, 06 Jun 2016 10:52:00 +0800</pubDate><guid isPermaLink="false">tag:seekiu.com,2016-06-06:/2016/git-notes.html</guid><category>DS相关</category></item><item><title>用 pelican 创建静态网站放到 GitHub 上</title><link>http://seekiu.com/2016/creat-pelican-site-github-pages.html</link><description>&lt;p&gt;去年在 GoDaddy 买域名半送的 Linux 空间到期了，最近一直在找替代方案。大致的方向是想用 GitHub 免费的 github pages 作为 host，因为此前已经知道 jekyll 是一个选项。但是考虑到 jekyll 是基于 Ruby 的，而我又不想在电脑里再多装一个我不太可能会用到的编程语言，因此搜索了一下基于 Python 的方案，果然，很轻松就地找到了 &lt;a href="blog.getpelican.com"&gt;pelican&lt;/a&gt;。&lt;/p&gt;
&lt;p&gt;以下是我用 pelican 创建静态网站并托管到 github pages 的流程，希望能让其他看到的人省点时间。另一点专门写出来的原因是，目前我在网上找到的关于 pelican 的教程绝大部分都是针对 Linux 系统的，像 &lt;code&gt;make&lt;/code&gt; 之类的命令在 Windows 下根本就不适用，因此我也花了不少准备的时间才把这个系统搭起来。&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;准备工作&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;Python 环境 …&lt;/p&gt;</description><dc:creator xmlns:dc="http://purl.org/dc/elements/1.1/">Charles Chen</dc:creator><pubDate>Wed, 01 Jun 2016 22:01:00 +0800</pubDate><guid isPermaLink="false">tag:seekiu.com,2016-06-01:/2016/creat-pelican-site-github-pages.html</guid><category>pelican</category></item><item><title>Hello Pelican!</title><link>http://seekiu.com/2016/hello-world-pelican.html</link><description>&lt;p&gt;Hello world from Pelican!&lt;/p&gt;</description><dc:creator xmlns:dc="http://purl.org/dc/elements/1.1/">Charles Chen</dc:creator><pubDate>Wed, 01 Jun 2016 16:50:00 +0800</pubDate><guid isPermaLink="false">tag:seekiu.com,2016-06-01:/2016/hello-world-pelican.html</guid></item><item><title>High-level GPU-accelerated Program in Python</title><link>http://seekiu.com/2015/high-level-gpu-programming-gpu-python.html</link><description>&lt;p&gt;After some basic digging, sadly I found that currently (2015.12) there&amp;#8217;s (probably) no mature solution that offers simple high-level GPU programming in Python. The commercial NumbaPro is promising, especially considering the success of its free version numba. However from my test, the JITted program is still highly unstable …&lt;/p&gt;</description><dc:creator xmlns:dc="http://purl.org/dc/elements/1.1/">Charles Chen</dc:creator><pubDate>Tue, 22 Dec 2015 09:58:00 +0800</pubDate><guid isPermaLink="false">tag:seekiu.com,2015-12-22:/2015/high-level-gpu-programming-gpu-python.html</guid><category>编程</category></item><item><title>Python中指针式传递的函数遇到的问题</title><link>http://seekiu.com/2015/python-pass-parameter-as-pointer-problem.html</link><description>&lt;p&gt;最近在尝试通过 multiprocessing 把原来的计算核心改为通过多进程实现的并行程序，但碰到了一个非常奇怪的问题，经过一些时间的排查，终于找到了问题所在。虽然问题本身很简单，但也许也有一定典型性，尤其是对编程新手而言，因此在这里用最简单的模型重现一下。&lt;/p&gt;
&lt;p&gt;首先从下面一段非常简单的程序开始：&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;def main():
    x = [1, 2, 3, 4, 5]
    foo(x)
    print(x)

def foo(x):
    bar(x)
    # x = bar2(x)
    for i in range(len(x)):
        x[i] = x[i]**2

def bar(x):
    for i in range(len …&lt;/pre&gt;&lt;/div&gt;</description><dc:creator xmlns:dc="http://purl.org/dc/elements/1.1/">Charles Chen</dc:creator><pubDate>Wed, 18 Nov 2015 19:25:00 +0800</pubDate><guid isPermaLink="false">tag:seekiu.com,2015-11-18:/2015/python-pass-parameter-as-pointer-problem.html</guid><category>编程</category></item><item><title>用LaTeX写文章的一种懒人写法</title><link>http://seekiu.com/2015/lazy-way-of-latex.html</link><description>&lt;p&gt;自从两年前用 LaTeX 写了第一篇论文，后续的几篇都回到了用 Word。主要原因在于学会用 LaTeX 之后，用 Word 的习惯也好了很多，再加上后者还有所见即所得的优势。不过回顾一些以前写的小笔记，发现如果做某个小专题的笔记，页数在十几页范围以内时，其实用 LaTeX 也是不错的选择，尤其是当出现大量公式的时候。正好最近要写一个简单的报告，就尝试着用 LaTeX 来写。由于已经比较长时间没有使用了，不少命令已经记得不熟了，另外也习惯了 markdown 那种接近所见即所得的方便，所以感觉纯 LaTeX 已经显得挺繁琐了。&lt;/p&gt;
&lt;p&gt;基于这样的背景，大概考虑了有几种方案。&lt;/p&gt;
&lt;p&gt;直接用 iPython notebook 其实是个不错的办法，尤其是要写的东西里出现大量公式的时候。用它最大的好处在于可以一个单元一个单元地敲，然后几乎实时地看到公式的样子，而不是对着一堆很难用人眼「编译」的代码来看。但它的问题也比较明显，输出效果最好的是 HTML 文件，虽然也可以得到 PDF，但样式几乎没办法控制 …&lt;/p&gt;</description><dc:creator xmlns:dc="http://purl.org/dc/elements/1.1/">Charles Chen</dc:creator><pubDate>Thu, 08 Oct 2015 10:12:00 +0800</pubDate><guid isPermaLink="false">tag:seekiu.com,2015-10-08:/2015/lazy-way-of-latex.html</guid><category>工具</category></item><item><title>新手向教程：用 Photoshop 将照片处理成扫描的效果</title><link>http://seekiu.com/2015/photoshop-scan-effect.html</link><description>&lt;p&gt;最近接到一个简单但十分繁琐的任务，要将几百张用手机、微单拍下来的文档照片，处理成方便打印的效果，也就是类似扫描的效果。本文记录了我用 Photoshop 处理用到的几个小技巧，虽然都是比较初级的办法，但希望能给有需要的人提供借鉴。&lt;/p&gt;
&lt;h1&gt;达到扫描效果&lt;/h1&gt;
&lt;p&gt;相机拍出来的照片与扫描仪扫出来的图片，最显著的区别是照片中，白纸上由于光线的原因，会出现亮度的差异，而扫描仪则会直接把这些部分「还原」成纸原来的纯白色，直接抹掉灰度较低的部分。&lt;/p&gt;
&lt;p&gt;要做到这一步，其实比较简单，可参考&lt;a href="http://blog.csdn.net/pleasecallmewhy/article/details/8776998"&gt;这篇文章&lt;/a&gt;的做法，大致有以下几个步骤：&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;导入所拍的照片，复制背景图层。&lt;/li&gt;
&lt;li&gt;对背景副本图层使用滤镜-模糊-高斯模糊，半径为100像素。&lt;/li&gt;
&lt;li&gt;将背景副本图层的混合模式改为「划分」（图层）。&lt;/li&gt;
&lt;li&gt;添加曲线调整层（调整-曲线），把曲线中部拉低一些，使得文字更清楚。&lt;/li&gt;
&lt;li&gt;合并可见图层。&lt;/li&gt;
&lt;li&gt;用柔画笔擦掉多余的噪点和边缘的背景等。&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;至此，在绝大多数情况下，都可以达到基本与扫描的效果一致，少数情况下也会出现效果不佳，这时用类似的方法做一些微调即可。&lt;/p&gt;
&lt;h1&gt;局部加黑&lt;/h1&gt;
&lt;p&gt;有一个常见的问题是，某些地方可能由于各种原因，文字显得非常淡，在墨不太足的打印机上打印出来可能根本看不见，这时就需要对局部进行加黑了，也很简单 …&lt;/p&gt;</description><dc:creator xmlns:dc="http://purl.org/dc/elements/1.1/">Charles Chen</dc:creator><pubDate>Sat, 29 Aug 2015 10:06:00 +0800</pubDate><guid isPermaLink="false">tag:seekiu.com,2015-08-29:/2015/photoshop-scan-effect.html</guid><category>工具</category></item><item><title>初试 Julia 语言</title><link>http://seekiu.com/2015/try-julia.html</link><description>&lt;p&gt;上一篇博文中推荐了 Python 的 JIT 编译器 numba，这两天又用空余的时间尝试了一下最近的一个新兴语言 Julia。Julia 的目标设定得很高，未来是要成为一个速度上接近甚至超过 Fortran/C 这样的传统语言的&lt;strong&gt;通用&lt;/strong&gt;编程语言。然而就我这两天很初步的尝试结果看来，它也许有这个能力，但至少目前，对工程计算的人来说，还没有达到 production-ready 的程度。（当然，这只是基于我个人的编程经验和需求的结论，很可能不适用于其他人。而且Julia本身是一门相对年轻的语言，很值得持续关注。）&lt;/p&gt;
&lt;p&gt;之所以这样说，有三个方面的理由：&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;作为一个&lt;strong&gt;动态语言&lt;/strong&gt;，它的 JIT 编译器（在很多情况下）还没有智能到，让我可以同时享受动态语言的便利和它的速度优势。例如最近我在试用 Julia 时最先尝试的就是把原来用 Numba 写的函数重写一遍，然而发现结果非常不好。Julia 版本的函数执行速度相当于纯 Python 的速度，与 Numba …&lt;/li&gt;&lt;/ol&gt;</description><dc:creator xmlns:dc="http://purl.org/dc/elements/1.1/">Charles Chen</dc:creator><pubDate>Mon, 10 Aug 2015 12:55:00 +0800</pubDate><guid isPermaLink="false">tag:seekiu.com,2015-08-10:/2015/try-julia.html</guid><category>编程</category></item><item><title>推荐使用Numba加速Python科学计算</title><link>http://seekiu.com/2015/use-numba-to-accelerate-python.html</link><description>&lt;p&gt;因为正在用 Python 写 &lt;a href="https://en.wikipedia.org/wiki/Lattice_Boltzmann_method"&gt;lattice Boltzmann&lt;/a&gt; 的原因，我时不时也会研究 Python 科学计算程序的加速方法。现在为止，陆续尝试过了几个方案，包括 numexpr、Cython 等等，也写了一些博文（&lt;a href="http://www.seekiu.com/2014/%E7%94%A8-numexpr-%E5%BA%93%E4%BC%98%E5%8C%96-numpy-%E8%AE%A1%E7%AE%97%E9%80%9F%E5%BA%A6"&gt;1&lt;/a&gt;、&lt;a href="http://www.seekiu.com/2014/%E7%94%A8-numexpr-%E5%BA%93%E4%BC%98%E5%8C%96-numpy-%E8%AE%A1%E7%AE%97%E9%80%9F%E5%BA%A6"&gt;2&lt;/a&gt;）。而这篇文章，则是要作一个推荐，建议所有在使用 Python 做科学计算的人尝试一下 Numba。&lt;/p&gt;
&lt;p&gt;推荐的原因，首先得从 Python 科学计算说起。&lt;/p&gt;
&lt;p&gt;Python 本身由于其动态语言的本质，并不适合于计算量很大的科学计算。然而 Numpy 提供的带类型的数据结构，以及预编译好的基于 C 或 Fortran 的高速计算库，很大程度上解决了这个问题。绝大部分基于 Python 的科学计算程序，都是将其数据储存在 ndarray 里的。按我自己目前的认识，Numpy _至少_带来了两个方面的好处，一是存储的数据带有类型 …&lt;/p&gt;</description><dc:creator xmlns:dc="http://purl.org/dc/elements/1.1/">Charles Chen</dc:creator><pubDate>Thu, 02 Jul 2015 20:49:00 +0800</pubDate><guid isPermaLink="false">tag:seekiu.com,2015-07-02:/2015/use-numba-to-accelerate-python.html</guid><category>编程</category></item><item><title>如何在Windows下给Vim安装YouCompleteMe</title><link>http://seekiu.com/2015/install-youcompleteme-windows.html</link><description>&lt;p&gt;更合理的一个标题是「A (far from perfect) guide for installing YouCompleteMe under Windows」，因为虽然我已经成功地安装好了YCM，但确实全程都非常不优雅。此处「优雅」的定义为有良好的可重现能力，换一台机器同样可以比较轻松地重新安装一遍。不管怎样，不优雅的过程还是值得记录一下的。&lt;/p&gt;
&lt;p&gt;由于YCM官方没有提供Windows下的安装指南，我主要参考的是&lt;a href="https://bitbucket.org/Haroogan/vim-youcompleteme-for-windows/"&gt;Haroogan的方案&lt;/a&gt;。&lt;/p&gt;
&lt;p&gt;安装YCM有几个基本的要求：&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;包含Python支持的Vim版本。&lt;/li&gt;
&lt;li&gt;LLVM/Clang，具体地说其实是&lt;code&gt;libclang.dll&lt;/code&gt;这一个文件。&lt;/li&gt;
&lt;li&gt;Haroogan预编译好的YCM库，主要是指&lt;code&gt;ycm_core.pyd&lt;/code&gt;这个文件。&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;检查Vim的Python支持的办法是在cmd中运行&lt;code&gt;python --version&lt;/code&gt;看看出来的Python前面是否有加号，或者在Vim中执行&lt;code&gt;:echo has('python')&lt;/code&gt;。不过相信会看这篇文章的多半是从官网下的gvim74，很不幸地这个版本并不支持Python。&lt;/p&gt;
&lt;p&gt;不过Haroogan同学很贴心地给出了全套解决方案，上面的三个基本要求他都提供了预编译好的版本：&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;带Python和其它一大票语言支持的&lt;a href="https://bitbucket.org/Haroogan/vim-for-windows"&gt;Vim&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href="https://bitbucket.org/Haroogan/llvm-for-windows"&gt;LLVM …&lt;/a&gt;&lt;/li&gt;&lt;/ol&gt;</description><dc:creator xmlns:dc="http://purl.org/dc/elements/1.1/">Charles Chen</dc:creator><pubDate>Sat, 30 May 2015 20:15:00 +0800</pubDate><guid isPermaLink="false">tag:seekiu.com,2015-05-30:/2015/install-youcompleteme-windows.html</guid><category>工具</category><category>Vim</category></item><item><title>高效的沟通有时需要省略不必要的细节</title><link>http://seekiu.com/2015/communication-detail.html</link><description>&lt;p&gt;先讲一个编造的故事。&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;小新在科研中遇到一个问题，要求求解一个几乎不可能得到分析解的一元方程，小新通过查文献，发现牛顿迭代可以用数值解法得到解，于是自己开始写程序实现牛顿迭代。小新在这个问题上已经困扰了很久，因此很高兴地向老板汇报，说他终于找到可行的办法了，两天内就可以得到结果！但小新在计算的时候发现，自己的那个方程在某些系数的条件下，对给定的初值非常敏感，迭代不稳定，结果容易发散。然后经过仔细排查，发现如果不让两次迭代的结果跨越太大，比如添加一个系数，让下一步的解只跳一半的距离，迭代就稳定多了。经过加班加点，总算在两天之内按照改进的迭代算法，得到了正确的结果。&lt;/p&gt;
&lt;p&gt;然而在向老板报告结果的时候，小新遇到了意想不到的麻烦。他向老板大致地讲了牛顿迭代的原理（编造的故事，不用在意细节~），然后重点讲了自己在迭代计算中做出的改进，最后简单讲了一下计算的结果。小新的意图是，强调自己在迭代算法中的创新，来突出自己做的工作，毕竟也是在这部分花费了最多的时间，也是最「原创」的工作。然而，从老板的角度来看，他的目的只是得到方程的解，本来听牛顿迭代就已经云里雾里了，然后又听小新大篇幅地讲了他在牛顿迭代上做的&lt;strong&gt;修改&lt;/strong&gt;，怎么听都不怎么靠谱。因此，本来一次比较简短的讨论会，介绍一下采用的求解方法，然后交流一下求解的结果，最后却变成了在算法的细节上无休止的争论。老板认为小新修改了别人的算法 …&lt;/p&gt;&lt;/blockquote&gt;</description><dc:creator xmlns:dc="http://purl.org/dc/elements/1.1/">Charles Chen</dc:creator><pubDate>Tue, 26 May 2015 06:07:00 +0800</pubDate><guid isPermaLink="false">tag:seekiu.com,2015-05-26:/2015/communication-detail.html</guid><category>个人</category></item><item><title>Matplotlib快速参考</title><link>http://seekiu.com/2015/matplotlib-ref.html</link><description>&lt;p&gt;写了一个笔记，关于Matplotlib的实用小索引。&lt;/p&gt;
&lt;p&gt;因为是用iPython写的，直接导出成静态的html文件了，还好Farbox也同时支持静态页面，只是需要手动链接一下。&lt;/p&gt;
&lt;p&gt;笔记的链接是 &lt;a href="http://seekiu.farbox.com/201504-mpl_ref.html"&gt;http://seekiu.farbox.com/201504-mpl_ref.html&lt;/a&gt;&lt;/p&gt;</description><dc:creator xmlns:dc="http://purl.org/dc/elements/1.1/">Charles Chen</dc:creator><pubDate>Sun, 26 Apr 2015 06:05:00 +0800</pubDate><guid isPermaLink="false">tag:seekiu.com,2015-04-26:/2015/matplotlib-ref.html</guid><category>编程</category></item><item><title>关于效率的一点新想法——不同时期的「效率」概念</title><link>http://seekiu.com/2015/productivity-periods.html</link><description>&lt;p&gt;相信现在相当一部分人都和我一下，曾经或现在仍有一种心理，认为自己现在的工作、科研、学习效率远不如高中时的自己。这其中大多数应该也在_口头上_表达过「要是能有那时的效率，现在应该能做出好得多的成绩吧」的说法，当然也仅限于口头上而已，因为其实心里都知道，这不可能实现，即使实现了也未必能达到那样的结果。&lt;/p&gt;
&lt;p&gt;说得俗一些，这种心理叫&lt;strong&gt;中二&lt;/strong&gt;，说得难听点，算是一种为自己开脱的一种说辞。本文无意于评价这种心理如何，而是想写一些对它的理性的思考。&lt;/p&gt;
&lt;p&gt;现在的我们（工作的、读研究生的、上大学的）不再能实现中学时代的集中精力，原因是多方面的，分心的事情更多&lt;strong&gt;得多&lt;/strong&gt;，生活中要面对的琐事也更多。&lt;/p&gt;
&lt;p&gt;但除开这些，假如我们没有手机，不会再随时被微信、手机游戏干扰，假如我们像以前在家一样，有一个贴心的管家帮我们打点好生活，是否我们的效率就能大幅度提升呢？&lt;/p&gt;
&lt;p&gt;是也不是。&lt;/p&gt;
&lt;p&gt;首先可以肯定的是，假如没有&lt;strong&gt;过于方便&lt;/strong&gt;的社交和娱乐，我们大脑受到的干扰会少得多，与原来相比，工作时精力肯定会更集中，效率（productivity）也会有可观的提升。&lt;/p&gt;
&lt;p&gt;然而，很多新人，包括我自己 …&lt;/p&gt;</description><dc:creator xmlns:dc="http://purl.org/dc/elements/1.1/">Charles Chen</dc:creator><pubDate>Sun, 26 Apr 2015 06:04:00 +0800</pubDate><guid isPermaLink="false">tag:seekiu.com,2015-04-26:/2015/productivity-periods.html</guid><category>个人</category></item><item><title>关于《Do it now!》的笔记</title><link>http://seekiu.com/2015/do-it-now-notes.html</link><description>&lt;p&gt;Steve Pavlina写的博文《Do it now!》，在我读本科的时候给过我很多启发和激励。在现在读博士的期间，遇到困难的时候，我也喜欢时不时翻出来读一读。作者Steve自己在九十年代上本科的时候，决定挑战一下自己，用三_学期_的时间，来完成别人通常花四年时间才能完成的本科学业，最终他完成了自己定下的目标，并以相当优秀的成绩毕业。这样的故事，放在如今这个浮躁的时代，算是十分符合它的风气。但有点讽刺的是，文章中最强调的核心思想，却恰恰是与浮躁相悖的，甚至这篇文章本身，它的篇幅，在现在动不动都是一百四十字限制的微博时代，也显得有些格格不入。&lt;/p&gt;
&lt;p&gt;说实话，到目前为止，我对Steve讲的这个故事，也并非百分之百全信，因为要坚持做完这样一件事，需要相当强大的决心和毅力，仅就我现实中认识的人而言，尚没有一人能做到。有趣的是，随着我自己读这篇文章的次数增多，通过一些实践中的体会，却渐渐发现它讲的一些东西很有道理。也因此增加了一些对它的信任度。&lt;/p&gt;
&lt;p&gt;以下是2015年2月，寒假在家的时候，读大约第十几遍的时候，写的一点感想。&lt;!--more--&gt;&lt;/p&gt;
&lt;p&gt;这篇文章有很多论点，粗看起来都很有道理，但对我而言，也仅限于「看起来很有道理」而已。比如文章开头的时候强调的，「Clarity …&lt;/p&gt;</description><dc:creator xmlns:dc="http://purl.org/dc/elements/1.1/">Charles Chen</dc:creator><pubDate>Thu, 26 Feb 2015 06:03:00 +0800</pubDate><guid isPermaLink="false">tag:seekiu.com,2015-02-26:/2015/do-it-now-notes.html</guid></item><item><title>Vim 系列（三） 进入 comfort zone</title><link>http://seekiu.com/2015/vim3.html</link><description>&lt;p&gt;尝试从 Sublime 迁移到 Vim 有一些时间了，现在基本适应（算不上熟悉）它的基本操作方式，配置了一些用得上的插件，基本上可以说进入 comfort zone 了。这其中最主要的一点是，一方面适应了 vim 某些方面更便捷的一些操作，另一方面，也基本找到了 sublime 中一些很常用功能的替代品。&lt;/p&gt;
&lt;p&gt;首先是学会了安装插件，我采用的办法是 Pathogen。虽然网上现在现多的声音支持 Vundle，它也似乎相对更接近 sublime 中的 package control 的功能，但对我而言它有一个非常大的不便，就是必须信赖 GIT，而我至少目前为止，还没有想法去折腾它。另一方面，Pathogen 相对简单很多，新建一个 bundle 文件夹，然后把相应的插件从 Github 上下载下来丢到里面即可（感谢 Github 提供了从网页下载 zip …&lt;/p&gt;</description><dc:creator xmlns:dc="http://purl.org/dc/elements/1.1/">Charles Chen</dc:creator><pubDate>Sun, 08 Feb 2015 21:21:00 +0800</pubDate><guid isPermaLink="false">tag:seekiu.com,2015-02-08:/2015/vim3.html</guid><category>工具</category></item><item><title>修复Windows中批处理启动Vim的奇怪问题</title><link>http://seekiu.com/2015/fix-vim-startup-by-bat.html</link><description>&lt;p&gt;现在在笔记本和工作站上都安装上了 Vim，但这两天发现了一个非常奇怪的问题，SP3 上在批处理文件中启动 vim 时，会非常不按常规地出现或关闭命令行窗口。本来加 &lt;code&gt;start&lt;/code&gt; 是继续批处理的后面命令或者直接关掉命令行，结果莫名其妙总是多出来一个窗口，需要等它执行完再进行下一个命令的时候它又变成了加 &lt;code&gt;start&lt;/code&gt; 的模式。&lt;/p&gt;
&lt;p&gt;经过排查，发现直接运行 gvim 或者 vim 的时候显示的工作目录是 C:\Windows，总算明白问题出在安装时勾上的 create bat file to use in command line （凭记忆写的，大概这个意思），它其实在这个目录下创建了一个快捷方式。把这个一点都不快捷的bat删掉（以防万一只在文件名加.bak），然后把真正的 gvim.exe 所在目录加入到系统 PATH，这样处理之后，问题就解决了。&lt;/p&gt;</description><dc:creator xmlns:dc="http://purl.org/dc/elements/1.1/">Charles Chen</dc:creator><pubDate>Wed, 04 Feb 2015 21:20:00 +0800</pubDate><guid isPermaLink="false">tag:seekiu.com,2015-02-04:/2015/fix-vim-startup-by-bat.html</guid><category>工具</category><category>Vim</category></item><item><title>Vim 系列（二） 试用 Vim 几天的体会</title><link>http://seekiu.com/2015/vim2.html</link><description>&lt;p&gt;如前所述，最近尝试着把主要的文本编辑器从 Sublime Text 3 迁移到 Vim，试用了几天，有一些体会，本文尝试做一些小结。&lt;/p&gt;
&lt;p&gt;总的来说，从一个传统的编辑器到 Vim 的感觉，感觉很类似于学五笔的过程。&lt;/p&gt;
&lt;p&gt;从拼音到五笔，基本上是一个不向后兼容的过程，最开始的时候需要记忆一些东西，在前面不熟悉的一个月到甚至几个月，使用的时候还需要时不时地动脑想某个字或词的拆法。而等到使用了五笔一年以上之后，绝大部分字词的编码就开始形成肌肉记忆了，从这时候开始，打字速度就开始产生了质的提升。&lt;/p&gt;
&lt;p&gt;而刚开始使用 Vim 的时候，也有很强烈的这种感觉。最明显的一点是更方便但不那么直观的 HJKL 移动光标，对于习惯了鼠标或者方向键移动的人来说，就像是习惯了打拼音突然要打出一级简码一样，虽然方便，但经常都会按下以前熟悉的键才反应过来，哦，按错了。&lt;/p&gt;
&lt;p&gt;除此之外，由于我对 ST3 已经算是中度用户了，平时常用的快捷键大概也有十来个，一些 ST3 中很有特色的便携操作比如多列编辑、ctrl-D 的 multi-selection 等等，都暂时没有找到在 …&lt;/p&gt;</description><dc:creator xmlns:dc="http://purl.org/dc/elements/1.1/">Charles Chen</dc:creator><pubDate>Sat, 31 Jan 2015 21:19:00 +0800</pubDate><guid isPermaLink="false">tag:seekiu.com,2015-01-31:/2015/vim2.html</guid><category>工具</category><category>Vim</category></item><item><title>Vim 系列（一） Vim tutor 要点小结</title><link>http://seekiu.com/2015/vim1.html</link><description>&lt;p&gt;因为各种原因，准备慢慢把主要的编辑器从 Sublime Text 3 迁移至古老的 Vim。今天开始，不定期地更新一系列的学习笔记。这篇是第一篇，大致整理了一下自带的教程（vim tutor）中的主要内容。&lt;/p&gt;
&lt;p&gt;启动 Vim。把 vim 的目录添加到 PATH 中，则输入 &lt;code&gt;vim&lt;/code&gt; 可直接在命令行中启动 Vim，而 &lt;code&gt;gvim&lt;/code&gt; 则启动带界面的版本。&lt;/p&gt;
&lt;p&gt;Vim 有多种模式，其中最基本的是「普通模式」，启动 Vim 后默认打开的就是普通模式，普通模式中光标是覆盖在字符上的方块，而如果在「插入模式」中，光标是字符之间的一条闪烁的线（绝大多数程序中也如此）。如果处在其它模式中，多按几次 ESC 就可以回到普通模式。&lt;/p&gt;
&lt;p&gt;普通模式下的光标移动。最基本的是用 &lt;code&gt;hjkl&lt;/code&gt; 来实现上下左右，这一点刚上手 …&lt;/p&gt;</description><dc:creator xmlns:dc="http://purl.org/dc/elements/1.1/">Charles Chen</dc:creator><pubDate>Tue, 27 Jan 2015 21:17:00 +0800</pubDate><guid isPermaLink="false">tag:seekiu.com,2015-01-27:/2015/vim1.html</guid><category>工具</category></item><item><title>奇怪的bug，win8里的ctrl-backspace失效了</title><link>http://seekiu.com/2015/ctrl-backspace-not-working.html</link><description>&lt;p&gt;最近遇到一个十分奇怪的bug，用于删除前一个单词的ctrl-backspace快捷键失效了。甚至在sublime text这种另外定义了这个快捷键行为的软件里也一样，奇怪。&lt;/p&gt;
&lt;p&gt;最开始是在一个机器上出现的，而记忆中唯一记得的近期对它做过的最大改动是把Python升级到了3.4，并删掉了原来的2.7，但暂时还无法确认是这个问题。更奇怪的是，在一台新的机器上，最开始没有这个问题，没过多久也出现了。&lt;/p&gt;
&lt;p&gt;另外自己的一台电脑上是从win7升级上来的，没有出现这个情况。&lt;/p&gt;
&lt;p&gt;Google了一番，似乎没有人出现过类似的情况。&lt;/p&gt;
&lt;p&gt;太奇怪了。&lt;/p&gt;</description><dc:creator xmlns:dc="http://purl.org/dc/elements/1.1/">Charles Chen</dc:creator><pubDate>Wed, 21 Jan 2015 21:16:00 +0800</pubDate><guid isPermaLink="false">tag:seekiu.com,2015-01-21:/2015/ctrl-backspace-not-working.html</guid><category>工具</category></item><item><title>一个反直觉数学题的程序验证</title><link>http://seekiu.com/2014/program-to-verify-counterintuitive-math-problem.html</link><description>&lt;p&gt;很久之前看到的东西了，今天总算抽空把它写完了。&lt;/p&gt;
&lt;p&gt;最开始是在 Quora 上看到一个很有意思的&lt;a href="http://www.quora.com/What-are-the-most-interesting-or-popular-probability-puzzles-in-which-the-intuition-is-contrary-to-the-solution/answer/Alon-Amit"&gt;答案&lt;/a&gt;，虽然是简单的抛硬币问题，但结果确实是相当反直觉，因此，干脆用 Python 写了一系列的小程序，来验证这些结果。&lt;/p&gt;
&lt;p&gt;第一个游戏很简单，抛一个硬币，连续抛两次，先后出现正面（heads，后面记为H）和反面（tail，后面记为T）的概率是ht，先后出现HH的概率记为hh。很显然，两者相等。程序验证也很简单，试验十万次，看分别出现多少次。&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;def game1():  
    # flip twice, the possibility of HH or HT  
    hh = 0; ht = 0  
    for i in xrange(100000):  
        pre = &amp;#39;&amp;#39;; cur …&lt;/pre&gt;&lt;/div&gt;</description><dc:creator xmlns:dc="http://purl.org/dc/elements/1.1/">Charles Chen</dc:creator><pubDate>Fri, 14 Nov 2014 21:13:00 +0800</pubDate><guid isPermaLink="false">tag:seekiu.com,2014-11-14:/2014/program-to-verify-counterintuitive-math-problem.html</guid><category>编程</category></item><item><title>用 Python 简化数据处理流程的 workflow 及简单示范</title><link>http://seekiu.com/2014/python-workflow-simplify-data-processing.html</link><description>&lt;p&gt;注：本文所述方法肯定不是最简单的，但对我这非编程相关专业的人来说已经提高很多效率了。如果你有更好的办法，欢迎留言。&lt;/p&gt;
&lt;p&gt;如果同样的一个程序，改变一系列参数，分别计算结果，我一般选择把这个程序复制很多份，放在不同的文件夹里，然后写几个批处理文件（写几个是为了能同时几个一起算），按一定的次序分别执行它们，并把结果保存的相应的目录。保存的结果有很多时候是逗号分隔的csv文件，这时候如果想作图的话，就需要从每个文件中拷出数据来，然后复制到 Origin 中进行绘图。&lt;/p&gt;
&lt;p&gt;这样的 workflow 在对付我之前面对的多数问题都 ok，但如果保存的数据量大了，尤其是每一个 csv 文件中的列数多了（比如10列以上），或者 copy 出来的数据需要进行修改、筛选等复杂操作时，就显得有些繁琐和吃力了。相比之下，用 Python 来读取数据，并进行后续的处理和绘图就会简单一些，并且有更好的一致性。&lt;/p&gt;
&lt;p&gt;举例来说，比如按不同的参数，跑了10组结果，分别存在 param1~param10的文件夹中，每个文件夹中都有 result.txt 的文件 …&lt;/p&gt;</description><dc:creator xmlns:dc="http://purl.org/dc/elements/1.1/">Charles Chen</dc:creator><pubDate>Thu, 07 Aug 2014 21:12:00 +0800</pubDate><guid isPermaLink="false">tag:seekiu.com,2014-08-07:/2014/python-workflow-simplify-data-processing.html</guid><category>编程</category></item><item><title>用Cython来加速Python的科学计算程序</title><link>http://seekiu.com/2014/use-cython-to-accelerate-python.html</link><description>&lt;p&gt;从网上照抄的一些 LBM 算例基本都是在规整的矩形区域内的计算，用简单的 Numpy 非常适合，但当需要计算一些稍微更复杂的计算域时，纯 Numpy 的计算逻辑就有点复杂了，这时最简单的办法还是循环计算节点，这时候就不得不请出 Cython 了。&lt;/p&gt;
&lt;p&gt;对我这种级别的人来说，Cython 基本上可以理解成用 Python 的语法来写 C，与 Python 的主要区别在于可以定义变量的类型，以及需要编译成 Python 库才能运行。这篇文章简单记录一下使用 Cython 的一些入门知识。&lt;/p&gt;
&lt;p&gt;使用 Cython，先需要建立一个 &lt;code&gt;pyx&lt;/code&gt; 格式的源文件，以计算宏观密度的函数为例，建立 &lt;code&gt;rho.pyx&lt;/code&gt; 文件，并写入如下的函数：&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;def calc_rho_notype(f):  
    rho = np.empty_like(f[:,:,0])  
    for i …&lt;/pre&gt;&lt;/div&gt;</description><dc:creator xmlns:dc="http://purl.org/dc/elements/1.1/">Charles Chen</dc:creator><pubDate>Thu, 24 Jul 2014 21:11:00 +0800</pubDate><guid isPermaLink="false">tag:seekiu.com,2014-07-24:/2014/use-cython-to-accelerate-python.html</guid><category>编程</category></item><item><title>把 python 科学计算环境换成了 Anaconda</title><link>http://seekiu.com/2014/use-anaconda.html</link><description>&lt;p&gt;此前尝试过 python(x,y)，但最终还是换回了纯 python 的环境，一方面是因为它太大，另一方面它实在包含了太多不可控的东西，包括潜在的污染系统 python 的危险等。偶然看到 Anaconda 的介绍，似乎是一种较为「绿色」的方案，而且带的科学计算包也比较全，试着装了一下，确实不错。Anaconda 的一个主要优势在于，它集成了绝大部分常用的计算包，并全部放在自己的文件夹中，与系统内已安装的 Python 相对独立，因此安装下来非常干净。如果其它人也想运行在这个环境下写出来的代码，只需要安装 Anaconda 环境即可，而不再需要一个一个把需要的包都下载下来，这一点，在与其它人交流代码时就太方便了。&lt;/p&gt;
&lt;p&gt;从原来配置的环境换到 Anaconda 也非常简单，大概会有这么几个问题：&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;
&lt;p&gt;删除重复的包，如 numpy / scipy / matplotlib 等，用 &lt;code&gt;pip uninstall&lt;/code&gt; 即可 …&lt;/p&gt;&lt;/li&gt;&lt;/ol&gt;</description><dc:creator xmlns:dc="http://purl.org/dc/elements/1.1/">Charles Chen</dc:creator><pubDate>Tue, 08 Jul 2014 21:07:00 +0800</pubDate><guid isPermaLink="false">tag:seekiu.com,2014-07-08:/2014/use-anaconda.html</guid><category>编程</category></item><item><title>用 VPN 时的一些小问题</title><link>http://seekiu.com/2014/problems-using-vpn.html</link><description>&lt;p&gt;从5月35日前两天左右开始，gg开始几乎全系被封，干脆买了个收费的 VPN，想一次性解决问题。当然，事实证明也没有这么简单，还是碰到了大大小小的不少问题，大致罗致如下：&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;L2** 比 PP** 的「安全性」更好，一般推荐用前者；&lt;/li&gt;
&lt;li&gt;路由表是个好东西，尤其是 chnroutes，它可以实现让国内流量不走 VPN，大量节约收费资源，并且提高速度；&lt;/li&gt;
&lt;li&gt;在我的情况里，L2** 协议再加载智能路由表时，会导致上不了百度，至今没弄明白怎么回事，现在较好的解决办法是在浏览器里再用一个自动代理，让域名带 baidu.com 的都从一个国内的高速缓存里过，算是一个曲线救国的办法了。&lt;/li&gt;
&lt;/ol&gt;</description><dc:creator xmlns:dc="http://purl.org/dc/elements/1.1/">Charles Chen</dc:creator><pubDate>Tue, 24 Jun 2014 21:06:00 +0800</pubDate><guid isPermaLink="false">tag:seekiu.com,2014-06-24:/2014/problems-using-vpn.html</guid><category>工具</category></item><item><title>Python 输出用于 Paraview 后处理的 vtk 文件</title><link>http://seekiu.com/2014/python-output-vtk-for-paraview.html</link><description>&lt;p&gt;好拗口的标题。。。&lt;/p&gt;
&lt;p&gt;前面的博客中已经提到，Python 有 Matplotlib 这种强大的包可以「在线」地生成（并保存）漂亮的图形，但对于计算流体力学的后处理来说，很多时候需要更多「事后」的后处理。在线的即时输出，虽然可以快速预览结果，但对于想输出什么结果必须在写程序阶段就全部想明白，而不是先计算完，按一定间隔输出整个流场的信息，然后后期想要什么数据慢慢提取分析就行。&lt;/p&gt;
&lt;p&gt;解决这个问题的方法也很简单，直接照抄开源 LBM 软件 Palabos 的方案，用 vtk 格式保存流场信息，然后用 Paraview 进行后处理。&lt;/p&gt;
&lt;p&gt;这个「十分简单」的技术路线结果却花了我很多天的时间，才基本搞清楚其中的奥秘，从多个 tricky part 中脱身。技术上来说，Python 输出 vtk 有成熟的软件包（我采用的是pyevtk 这个库[1]），实现方法也比较直观。例如官方提供的一个示例是这样的 …&lt;/p&gt;</description><dc:creator xmlns:dc="http://purl.org/dc/elements/1.1/">Charles Chen</dc:creator><pubDate>Fri, 23 May 2014 21:03:00 +0800</pubDate><guid isPermaLink="false">tag:seekiu.com,2014-05-23:/2014/python-output-vtk-for-paraview.html</guid><category>编程</category></item><item><title>用 numexpr 库优化 numpy 计算速度</title><link>http://seekiu.com/2014/use-numexpr-to-accelerate.html</link><description>&lt;p&gt;NumPy 虽然通过底层高度优化过的计算库可以实现接近C的高效计算，但在计算复杂且计算量庞大的时候多少还是有些嫌慢。Numexpr 库是最近发现的一个非常简单易用的 Numpy性能提升工具，很大程度上从我的需求上解决了性能的问题。&lt;/p&gt;
&lt;p&gt;先看一个例子：&lt;/p&gt;
&lt;pre&gt;&lt;code class="python"&gt;import numpy as np
import numexpr as ne
nx, ny = 1200, 1500
a = np.linspace(0.,3.1416,nx*ny).reshape(nx,ny)
for i in range(100):
    b = np.sin(a+i)**2 + np.cos(a+i)**2 + a**1.5 …&lt;/code&gt;&lt;/pre&gt;</description><dc:creator xmlns:dc="http://purl.org/dc/elements/1.1/">Charles Chen</dc:creator><pubDate>Thu, 22 May 2014 21:00:00 +0800</pubDate><guid isPermaLink="false">tag:seekiu.com,2014-05-22:/2014/use-numexpr-to-accelerate.html</guid><category>编程</category></item><item><title>关于 Numpy 数组作为函数参数的一个小问题</title><link>http://seekiu.com/2014/guan-yu-numpy-shu-zu-zuo-wei-han-shu-can-shu-de-yi-ge-xiao-wen-ti.html</link><description>&lt;blockquote&gt;
&lt;p&gt;注：本文的所写的只是我自己想出来的一个办法，很可能不是最优或者最标准的做法，如果有高手看到，欢迎指正！ &lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;在计算过程中遇到这样的一个问题，需要对一个 nx*ny 的网格上每一个节点调用一次函数，然后返回一个 nx*ny 的数组。&lt;/p&gt;
&lt;p&gt;我之前就写过类似的程序，numpy 可以直接调用普通的计算程序，比如：&lt;/p&gt;
&lt;pre class="lang:python decode:true " &gt;def x_square(x):
    return x*x
a = np.arange(nx*ny).reshape(nx,ny)
print x_square(a)&lt;/pre&gt;

&lt;p&gt;直接把 ndarray 对象作为参数传入函数，就可以得到一个正确的结果。&lt;/p&gt;
&lt;p&gt;于是，想当然地，也针对上面的需求，写了这样一个程序：&lt;/p&gt;
&lt;pre class="lang:python decode:true " &gt;ff = np.linspace(1.0,2.0 …&lt;/pre&gt;</description><dc:creator xmlns:dc="http://purl.org/dc/elements/1.1/">Charles Chen</dc:creator><pubDate>Fri, 16 May 2014 20:56:00 +0800</pubDate><guid isPermaLink="false">tag:seekiu.com,2014-05-16:/2014/guan-yu-numpy-shu-zu-zuo-wei-han-shu-can-shu-de-yi-ge-xiao-wen-ti.html</guid><category>编程</category></item><item><title>用Python作流场计算时的后处理问题</title><link>http://seekiu.com/2014/yong-pythonzuo-liu-chang-ji-suan-shi-de-hou-chu-li-wen-ti.html</link><description>&lt;p&gt;由于我现在正试图用Numpy来实现 Lattice Boltzmann method 的算法，也会涉及到一些简单的后处理功能。这里的后处理具体的说是输出一些关于流场的图像问题，因为输出单点的信息没有任何难度。而图像输出主要是依靠 Matplotlib 这个强大的库来完成。后续如果要做进一步的后处理的话，应该还是要学一学如何导出数据到专业后处理软件中，但就调试过程而言，能及时输出一些直观的图像是十分必要的。&lt;/p&gt;
&lt;p&gt;我现在采用的办法是把关于流场的属性存储于数组中（rho[nx_ny]、u[nx_ny*2] 等），用 node 编号来索引具体的数值。这种情况，因为还不涉及格子单位和物理单位的转换，后处理的逻辑还是比较简单的。一般地说来，会用到的图像可分为两类，一类是标量场，主要是云图，另一类是矢量场，主要是矢量图（vector graph）和流线图。这两类图形的绘制方法都很接近，掌握一种的话，通过查询官方在线文档，基本都可以很快找到另外几种的用法。&lt;/p&gt;
&lt;p&gt;例如，对于标量场，如密度场 rho[nx*ny]，可以用 matplotlib.pyplot …&lt;/p&gt;</description><dc:creator xmlns:dc="http://purl.org/dc/elements/1.1/">Charles Chen</dc:creator><pubDate>Wed, 30 Apr 2014 20:48:00 +0800</pubDate><guid isPermaLink="false">tag:seekiu.com,2014-04-30:/2014/yong-pythonzuo-liu-chang-ji-suan-shi-de-hou-chu-li-wen-ti.html</guid><category>编程</category></item><item><title>时间管理第一课</title><link>http://seekiu.com/2013/shi-jian-guan-li-di-yi-ke.html</link><description>&lt;p&gt;对我自己来说，如果要向别人讲时间管理，第一课也是传递「技巧」方面最重要的一课是一句话：快速推进，各个击破。&lt;/p&gt;
&lt;p&gt;类似的概念最开始是我自己在高中时候开始提出的，那时候课繁多，采用这样的办法很适合当时的状态。后来上大学似乎就渐渐忘了这样的风格，而是更自由更散漫了。&lt;/p&gt;
&lt;p&gt;重新想起这个概念是因为一句被我长期曲解的Facebook箴言：Move fast and break things。后半句被我理解成了分解任务，于是乎就产生了「快速推进，各个击破」的说法。&lt;/p&gt;
&lt;p&gt;其实实践下来，恰恰是这个原则最有用，尤其是在针对大块任务或者批量处理的时候。隐含的思路是，如果针对大块任务，把它分解成多个小任务，然后各个击破，而不是对着一个大块头发怵。&lt;/p&gt;
&lt;p&gt;简单实用的原则，值得写在记事本的第一页。&lt;/p&gt;</description><dc:creator xmlns:dc="http://purl.org/dc/elements/1.1/">Charles Chen</dc:creator><pubDate>Thu, 26 Sep 2013 06:01:00 +0800</pubDate><guid isPermaLink="false">tag:seekiu.com,2013-09-26:/2013/shi-jian-guan-li-di-yi-ke.html</guid><category>个人</category></item><item><title>用Sublime Text写作和记笔记</title><link>http://seekiu.com/2013/yong-sublime-textxie-zuo-he-ji-bi-ji.html</link><description>&lt;p&gt;上个学期的时候，发现了一个软件&lt;a href="https://www.literatureandlatte.com/scrivener.php"&gt;Scrivener&lt;/a&gt;，它本身号称是一个给作家使用的软件，当时觉得很适合，但可惜价格昂贵，而且对数学公式的支持很差（windows版），所以一直在寻找类似的替代品。找来找去，最后发现一直在使用的文本编辑器sublime text 2其实就已经可以很好地完成这个功能了。&lt;/p&gt;
&lt;p&gt;&lt;a href="http://www.sublimetext.com/"&gt;Sublime text&lt;/a&gt;是过去一段时间相当火的一个面向程序员的文本编辑器，有多个颇有新意有实用功能。虽然它几十刀的价格对穷学生来说相当没有亲和力，比Scrivener还贵一点，但作者也很厚道地允许无限试用，只是在使用时以相当低的频率弹出窗口提示买证书（似乎是按保存的次数来算的），也算是个准免费软件吧。&lt;/p&gt;
&lt;p&gt;废话不多说，简单说一下我怎么用ST2实现接近Scrivener的功能的。&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;准备工作：安装sublime text，建立存放文件的文件夹，如「research | journal | misc」；&lt;/li&gt;
&lt;li&gt;首先安装必要的插件，Sidebarenhancements，可以通过package control完成。&lt;/li&gt;
&lt;li&gt;新建一个Project。菜单栏Project&amp;#8211;Add folder to project&amp;#8230;，把上面这些文件夹依次添加进去，然后Project&amp;#8211;Save project as&amp;#8230;将其保存。如果没有清除记录的话 …&lt;/li&gt;&lt;/ol&gt;</description><dc:creator xmlns:dc="http://purl.org/dc/elements/1.1/">Charles Chen</dc:creator><pubDate>Mon, 26 Aug 2013 05:59:00 +0800</pubDate><guid isPermaLink="false">tag:seekiu.com,2013-08-26:/2013/yong-sublime-textxie-zuo-he-ji-bi-ji.html</guid><category>工具</category></item><item><title>编程两三事</title><link>http://seekiu.com/2013/bian-cheng-liang-san-shi.html</link><description>&lt;p&gt;学期末的时候有一些数据处理的任务，花了很长时间按部就班地以常规办法解决，基本上是在excel、Wolfram Alpha和origin中倒腾数据，在数据量少且源数据不变的时候，可以比较轻松地应付，但偏偏我的问题两个条件都不符合。后来按《你早该这样玩excel》里提的源数据表原则，排成了一个统一并大量冗余的源数据表，全部数据处理用公式完成，效率提高了不少，但依然不够满意。主要还是excel里批量处理的数据不能及时转为图像（不会啊。。。），它的公式处理也不够灵活，也缺少「拟合」这样的高级功能。&lt;/p&gt;
&lt;p&gt;后来其中某个小问题由于需要不停地迭代试算，实在伤脑筋，就干脆请身边的某matlab达人 ^[没错，就是传说中的鸡爷！] 帮忙编写了一个自动解决其中一部分问题的小程序，当时惊为天人。当然，没过多久，又开始对这个小程序不满足了，但这种提前告诉程序需要做什么事，然后具体的任务由它完成的思想给了我很好的启发。这个小程序解决的只是一部分需要迭代的小部分（甚至它都没实现迭代本身，只是自动实现了迭代的过程），而如果能由程序完成尽可能多的问题呢？&lt;/p&gt;
&lt;p&gt;刚好此前在室友的推荐下看过&lt;a href="http://hyry.dip.jp/tech/book/page/scipy/index.html"&gt;《用python作科学计算》&lt;/a&gt;，知道python的开源包一定程度上可以实现matlab的常用功能，又由于python本身是一个全功能的编程语言，因此就决定在暑假学一学python。&lt;/p&gt;
&lt;p&gt;说一下编程的两大罪状：&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;会不断地碰到小问题，不断地通过google、查文档解决，于是如果堆代码的过程比较顺利的话，就是一个不断地产生小成就感的过程。这种小成就感给人一种幻觉，让人觉得似乎完成了很大的成就 …&lt;/li&gt;&lt;/ol&gt;</description><dc:creator xmlns:dc="http://purl.org/dc/elements/1.1/">Charles Chen</dc:creator><pubDate>Mon, 26 Aug 2013 05:56:00 +0800</pubDate><guid isPermaLink="false">tag:seekiu.com,2013-08-26:/2013/bian-cheng-liang-san-shi.html</guid><category>编程</category></item><item><title>如先书记的故事</title><link>http://seekiu.com/2013/ru-xian-shu-ji-de-gu-shi.html</link><description>&lt;p&gt;如先书记是20世纪70年代为数不多的还有真功夫的人，在县里也小有名气。如先书记的出名主要是因为两件事：&lt;/p&gt;
&lt;p&gt;一次是下乡的时候，一行3人，遇到一群抬花轿的人，当时的政策不允许再用花轿，如先作为书记，便上前与人说理，却不料对方仗着人多，反倒想欺负人，两人制住如先书记的双手，另一个欲给以当面一拳，却不料如先一发力，竟将手中两人一齐甩出，出拳之人亦即惊呆，不再造次。旁人劝道，「您是书记，不能打人啊！」，如先曰，「我不打你们，如果我真要打，怕你们也承不住。」&lt;/p&gt;
&lt;p&gt;另一次是与外乡人喝酒，席间外乡人道，早闻如先书记功夫了得，何不一起耍耍，如先欣然应允。遂有四外乡人，都是农民出身，自认力气不小，两前两后，如先直立居其中，不执任何器物。前后四人倾尽其力，不可移其分毫。众皆奇之。&lt;/p&gt;
&lt;p&gt;当然，对如先的子女来说，记得更清楚的是，如果不小心割伤，血流不止，如先只需在伤口周围稍微按摩穴位，流血顷刻可止。可惜，此技已失传矣。&lt;/p&gt;
&lt;p&gt;&lt;em&gt;注：本文除人名外，故事大概属实 …&lt;/em&gt;&lt;/p&gt;</description><dc:creator xmlns:dc="http://purl.org/dc/elements/1.1/">Charles Chen</dc:creator><pubDate>Fri, 26 Jul 2013 05:55:00 +0800</pubDate><guid isPermaLink="false">tag:seekiu.com,2013-07-26:/2013/ru-xian-shu-ji-de-gu-shi.html</guid><category>个人</category></item><item><title>精力——旧观念与新想法</title><link>http://seekiu.com/2013/jing-li-jiu-guan-nian-yu-xin-xiang-fa.html</link><description>&lt;p&gt;本科的时候，接触过一些研究生，最重要的印象是这些老大不小的「学生」都好有精力，对很多东西都跃跃欲试，以至于看起来甚至还不如本科生成熟稳重。几年过去了，现在读起了博士，也在项目中带过本科生，身份互换了一下，想法也变了很多。&lt;/p&gt;
&lt;p&gt;最直接的变化是，从「老」博士的角度看，相当多「年轻」的本科生都不够有朝气。这当然有一定的客观原因，现在这个年代，晚上十一点前睡觉的都会被当成怪人，理工科大学的课业压力也是相当大，但另一方面，不讲究合理安排时间，拖延症严重（有几个人不是呢，sigh…），导致很多时候显得没精打采。&lt;/p&gt;
&lt;p&gt;一年前的我，大概也同样是这种情况，甚至经常被GF称为小老头。所幸，有两件重要的事改变了我的观念。&lt;/p&gt;
&lt;p&gt;其中一个，是同伴的影响。同一工作室的博士同学都相当努力，而且相当能折腾，很少看见他们像本科同学那样扎堆打游戏，却常常见到他们折腾一些稀奇的东西。这对我是很好的影响，不仅因为工作的激情会传染，变成更努力工作的动力，也因为这种「折腾」的态度，让人不知不觉地学会更热爱生活。&lt;/p&gt;
&lt;p&gt;另一个原因，是学车的经历。学车的地方离学校很远 …&lt;/p&gt;</description><dc:creator xmlns:dc="http://purl.org/dc/elements/1.1/">Charles Chen</dc:creator><pubDate>Sun, 26 May 2013 05:54:00 +0800</pubDate><guid isPermaLink="false">tag:seekiu.com,2013-05-26:/2013/jing-li-jiu-guan-nian-yu-xin-xiang-fa.html</guid></item><item><title>提高效率的工具(I)——Virtuawin</title><link>http://seekiu.com/2013/ti-gao-xiao-lu-de-gong-ju-i-virtuawin.html</link><description>&lt;p&gt;准备长期更新一个系列的文章，介绍几个自己觉得不错的效率软件，这次是给windows添加虚拟桌面功能的&lt;a href="http://virtuawin.sourceforge.net/"&gt;Virtuawin&lt;/a&gt;。&lt;/p&gt;
&lt;p&gt;Virtuawin（注意不是Virtualwin）是给Windows提供类似Ubuntu的工作空间的软件，可以创建多个虚拟桌面，然后方便地切换。&lt;/p&gt;
&lt;p&gt;这个软件最适合于整洁控，可以把打开的窗口分到不同的虚拟桌面里，而目前所处的桌面只保留一到两个窗口。比如打开网页听豆瓣fm的时候，由于不能最小化，就干脆把它单独放到某个最后的桌面里，或者在做网络调研的时候，可能会打开一大堆窗口，就可以把它们分类归到不同桌面上。&lt;/p&gt;
&lt;p&gt;我自己最近觉得很实用的一个方面是，当在工作站上算多个单线程的小程序的时候，就可以开启一堆窗口，每个桌面放几个，就不至于全部缩到任务栏的小图标里了。&lt;/p&gt;
&lt;p&gt;我自己的设置比较简单，3个虚拟桌面，后台运行的程序如豆瓣fm放第3个桌面，工作桌面为1和2，切换桌面的快捷键为ctrl+win+方向键，桌面间移动窗口的快捷键为alt+win+方向键。&lt;/p&gt;
&lt;p&gt;功能很简单，也很纯粹，没有不必要的东西。最大的遗憾是没有像Ubuntu那样漂亮的切换动画，可惜。&lt;/p&gt;</description><dc:creator xmlns:dc="http://purl.org/dc/elements/1.1/">Charles Chen</dc:creator><pubDate>Sun, 26 May 2013 05:51:00 +0800</pubDate><guid isPermaLink="false">tag:seekiu.com,2013-05-26:/2013/ti-gao-xiao-lu-de-gong-ju-i-virtuawin.html</guid><category>工具</category></item><item><title>工具软件</title><link>http://seekiu.com/2013/tool-software.html</link><description>&lt;p&gt;本科时参与过一个自主程度较高的科研项目，受益不少，指导老师也是现在的博士导师。最近自己又成了这种项目的小导师，与两位同我相差3级的本科同学交流后，有了一些感触。结合最近的一些思考，写下此文。&lt;/p&gt;
&lt;p&gt;印象中初中政治书上有一句话说，工具是人类身体的延伸。这句话挺精确的，通过延伸我们的身体，可以完成一些正常难以完成的事情，但过多地依赖这种工具，也会削弱我们自身的一些能力。典型的例子如代步工具自不必说，现代的手机也是一个例子，它既方便了远在千里之外的人交流，却又因为在饭桌上占用大部分人的注意力而妨碍了交流。工具的双重效果是其本质属性，以工具带来方便的同时，也应避免为工具所困。道理很浅显，但现代的工具又往往让我们迷失其中。&lt;/p&gt;
&lt;p&gt;大约一个月前，与两位本科生第一次交流。由于项目书中提到了一些工具软件如现在十分流行的Fluent，同学都表示很有兴趣。但我感觉两位同学对于工具的着迷程度胜过了对物理现象背后作用原理的兴趣，让我产生了一些忧虑。现代的工程仿真软件越做越庞大，功能越做越复杂，操作却越来越简单。在宣传中我们可以看到各种复杂绚丽的效果，不内行的人看得眼花缭乱，内行的人也越发乐此不疲。这本是一件好事，科研人员专心于研究事务，不善于宣传和表达，而这些工具某种程度上降低了他们的宣传门槛。&lt;/p&gt;
&lt;p&gt;但这学期我自己所研究的一些内容很大程度上改变了我的看法。起源是开始学习Surface Evolver这个相当小众的仿真软件，它是一位数学教授写的小软件，用来最基本的能量最小原理计算液面形状的。由于它基本上算是一个个人项目，所以软件界面、帮助文档什么的都相对还不齐全（也远没有像ANSYS这种商业软件的成熟）。它的网格算法与之前接触的ANSYS和Fluent的有限元或者有限体积法都有所不同 …&lt;/p&gt;</description><dc:creator xmlns:dc="http://purl.org/dc/elements/1.1/">Charles Chen</dc:creator><pubDate>Sat, 26 Jan 2013 05:33:00 +0800</pubDate><guid isPermaLink="false">tag:seekiu.com,2013-01-26:/2013/tool-software.html</guid><category>个人</category></item><item><title>南半球——海岛</title><link>http://seekiu.com/2013/island.html</link><description>&lt;p&gt;睡前看潘光旦写的《霭理士传》，讲到他在二十岁左右的青春时期曾独自在澳洲生活过几年，对其人格养成形成了重大影响。突然想起来我自己少年时期虽不曾有相同的幸运，却通过各种探险、传奇，对那个陌生的世界有所了解，并神往已久。&lt;/p&gt;
&lt;p&gt;多少儿时的梦想到现在都忘记了，突然想到这个，竟激动起来。&lt;/p&gt;
&lt;p&gt;有生之年，应该努力想办法去南半球，找个不那么喧闹的海岛看看，给儿时的自己还一个心愿。&lt;/p&gt;
&lt;p&gt;&lt;a href="http://www.seekiu.com/wp-content/uploads/2015/05/island.jpg"&gt;&lt;/a&gt;&lt;/p&gt;</description><dc:creator xmlns:dc="http://purl.org/dc/elements/1.1/">Charles Chen</dc:creator><pubDate>Sat, 26 Jan 2013 05:25:00 +0800</pubDate><guid isPermaLink="false">tag:seekiu.com,2013-01-26:/2013/island.html</guid><category>个人</category></item></channel></rss>